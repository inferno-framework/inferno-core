# frozen_string_literal: true

require_relative '../reference_extractor'

module Inferno
  module DSL
    module FHIREvaluation
      module Rules
        class AllProfilesHaveExamples < Rule
          attr_accessor :context, :unused_profile_urls

          def check(context)
            @context = context
            @unused_profile_urls = []
            options = context.config.data.to_hash['Rule']['AllProfilesHaveExamples']['ConformanceOption']

            if options['considerOnlyResourceType']
              context.ig.profiles.each do |structure_definition|
                next if structure_definition.abstract

                pass_flg = context.data.any? { |resource| resource.resourceType == structure_definition.type }
                unused_profile_urls << structure_definition.url unless pass_flg
              end
            end

            if options['considerMetaProfile']
              used_profiles = context.data.map do |resource|
                get_profiles_from_example(resource)
              end.flatten.uniq
              profile_is_used = proc do |profile|
                versioned_url = "#{profile.url}|#{profile.version}"
                used_profiles.include?(profile.url) || used_profiles.include?(versioned_url)
              end
              get_unused_profile_urls(context.ig.profiles, &profile_is_used)
            end

            if options['considerValidationResults']
              context.ig.profiles.each do |structure_definition|
                next if structure_definition.abstract

                pass_flg = validate(context.data, structure_definition)
                unused_profile_urls << structure_definition.url unless pass_flg
              end
            end

            unused_profile_urls.uniq!

            if unused_profile_urls.any?
              message = "Found profiles without examples: #{unused_profile_urls.join(', ')}"
              result = EvaluationResult.new(message, rule: self)
            else
              message = 'All profiles have example instances.'
              result = EvaluationResult.new(message, severity: 'success', rule: self)
            end

            context.add_result result
          end

          def validate(resources, structure_definition)
            pass_flg = false
            resources.each do |resource|
              next unless structure_definition.type == resource.resourceType

              pass_flg = true if structure_definition.validates_resource?(resource)

              if context.config.data.to_hash['Rule']['AllProfilesHaveExamples']['ExternalValidator']
                pass_flg != validate_from_external(resource)
              end
            end
            pass_flg
          end

          def validate_from_external(resource)
            wrapped_resource = {
              cliContext: {
                sv: '4.0.1',
                ig: [
                  context.ig.id
                ],
                locale: 'en'
              },
              filesToValidate: [
                {
                  fileName: "#{resource.resourceType}/#{resource.id}.json",
                  fileContent: resource.to_json,
                  fileType: 'json'
                }
              ],
              # To-do: replace sessionId later using Inferno's or autogenerated by the validator.
              sessionId: '32fc25cf-020e-4492-ace5-03fe904d22e0'
            }
            request_body = wrapped_resource.to_json

            response = Faraday.new(
              ENV.fetch('FHIR_RESOURCE_VALIDATOR_URL'),
              request: { timeout: 600 }
            ).post('validate', request_body, content_type: 'application/json')

            unless response.status == 200
              raise StandardError,
                    "Error occurred in the validator. Http response: #{response.status}"
            end

            JSON.parse(response.body)['issue'].any? do |issue|
              %w[error fatal].include?(issue['severity'])
            end
          end

          def get_profiles_from_example(resource)
            if resource.resourceType == 'Bundle'
              all_profiles = resource.entry.map do |entry|
                get_single_resource_profiles(entry.resource)
              end
              all_profiles << get_single_resource_profiles(resource)
              all_profiles.flatten.uniq
            else
              get_single_resource_profiles(resource)
            end
          end

          def get_single_resource_profiles(resource)
            resource&.meta&.profile || []
          end

          def get_unused_profile_urls(profiles, &profile_filter)
            profiles.each do |profile|
              unused_profile_urls.push profile.url unless profile_filter.call(profile)
            end
          end

        end
      end
    end
  end
end
